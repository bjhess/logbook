[2022-02-28]
Rebuilding from scratch. Using the built in authentication generator as well as knowledge gained from working on the official book. This version won't have live view out of the box, but that's not so necessary anyway.

Generated user auth as of Phoenix 1.6.6: https://hexdocs.pm/phoenix/mix_phx_gen_auth.html#content
https://hexdocs.pm/phoenix/Mix.Tasks.Phx.Gen.Auth.html

User authentication things to do after generation of code:
* Remove confirmation mechanism if prefer not to have it
* Make sure error messages do not notify user that email is already registered

Generated code...

In an app named Demo which had mix phx.gen.auth Accounts User users run on it, you will find a module named DemoWeb.UserAuth with plugs such as:

* fetch_current_user - fetches the current user information if available
* require_authenticated_user - must be invoked after fetch_current_user and requires that a current user exists and is authenticated
* redirect_if_user_is_authenticated - used for the few pages that must not be available to authenticated users

Confirmation

The generated functionality ships with an account confirmation mechanism, where users have to confirm their account, typically by email. However, the generated code does not forbid users from using the application if their accounts have not yet been confirmed. You can add this functionality by customizing the require_authenticated_user in the Auth module to check for the confirmed_at field (and any other property you desire).
HOW DO WE DISABLE THIS IF WE WANT?

Tracking sessions

All sessions and tokens are tracked in a separate table. This allows you to track how many sessions are active for each account. You could even expose this information to users if desired.

Note that whenever the password changes (either via reset password or directly), all tokens are deleted and the user has to log in again on all devices.

For instance, when you register an account, if the email is already registered, the code will notify the user the email is already registered.

[2022-02-23]
Going to start going through the book from Phoenix 1.14 to build things out.

Process is about Elixir processes, not operating system processes. [8]
Functions, rather than inheritance, help you roll your app into piplelines, where each function feeds into the next. Like building a shopping list for your requests. [10]
config/dev.exs has database evironment for dev local. [23]
Plug library is a specification for building applications that connect to the web. Each plug consumes and produces a common data structure called Plug.Conn. Remember, that struct represents the whole universe for a given request, because it has things that web applications need: the inbound request, the protocol, the parsed parameters, and so on. [30]
Think of each individual plug as a function that takes a conn, does something small, and returns a slightly changed conn. The web server provides the initial data for our request, and then Phoenix calls one plug after another. Each plug can transform the conn in some small way until you eventually send a response back to the user. [30]
Plugs are functions. Your web applications are pipelines of plugs. [31]
.ex files are compiled to .beam files to run on Erlang virtual machine. .exs files are Elixir scripts, compiled to memory each time they are run. Those are good for quick-changing scripts or standalone devlopment-time tasks. [32]
mix.exs seems to be like the Gemfile in Ruby. mix.lock seems to be Gemfile.lock [32]
lib/hello/application.ex has support for starting, stopping, and supervising each application. [32]
environments are in config. config.exs is the master, application-wide config. MIX_ENV switches between environments. [33]
lib/logbook_web/endpoint.ex has a bunch of plugs that do typical things webapps do. [34] I suspect I'll need to know more about this at some point:

  # Serve at "/" the static files from "priv/static" directory.
  #
  # You should set gzip to true if you are running phx.digest
  # when deploying your static files in production.
  plug Plug.Static,
    at: "/",
    from: :logbook,
    gzip: false,
    only: ~w(assets fonts images favicon.ico robots.txt)

Although applications usually have a single endpoint, Phoenix doesn’t limit the number of endpoints your application can have. For example, you could have your main application endpoint running on port 80 (HTTP) and 443 (HTTPS), as well as a specific admin endpoint running on a special port—let’s say 8443 (HTTPS)—with specific characteristics and security constraints.
Alternatively, we could break those endpoints into separate applications but still run them side by side. You’ll explore this later on when learning about umbrella projects. [35]

Phoenix separates views from templates. The template seems to be what I'd think of as a view in Rails. The view must be like...helpers? [38]
Context seems to be the general idea of MVC models. Context doesn't know about the controller, and the controller doesn't know about the business rules. [43]
You can run a Phoenix server inside iex shell with iex -S mix phx.server [44]


[2022-02-22]
Set up with guides and McCord's building a twitter app youtube video
